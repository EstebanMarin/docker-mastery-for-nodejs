* Docker Mastery node notes
  Here is a reinstall emacs [[http://ubuntuhandbook.org/index.php/2019/02/install-gnu-emacs-26-1-ubuntu-18-04-16-04-18-10/][reboot]] 
** Session 1 => docker-compose basics
*** Install Docker and docker-compose and post install
    Best advice is to follow documentation here, take into account that installation varies by OS and also /millage may vary/.
    - Docker install  https://docs.docker.com/compose/install/
    - Compose  https://docs.docker.com/compose/install/
    - Make sure to run post installation instructions https://docs.docker.com/install/linux/linux-postinstall/ (set correctly docker and docker-compose permissions specially linux)

    Lastly make sure that you are in the right *docker* and *docker-compose* versions
    #+begin_src zsh
     docker version
    #+end_src
    #+RESULTS:
    | Client:       | Docker                                   | Engine     | -        | Community |       |
    | Version:      | 19.03.6                                  |            |          |           |       |
    | API           | version:                                 | 1.4        |          |           |       |
    | Go            | version:                                 | go1.12.16  |          |           |       |
    | Git           | commit:                                  | 369ce74a3c |          |           |       |
    | Built:        | Thu                                      | Feb        | 13       | 01:27:49  |  2020 |
    | OS/Arch:      | linux/amd64                              |            |          |           |       |
    | Experimental: | false                                    |            |          |           |       |
    | Server:       | Docker                                   | Engine     | -        | Community |       |
    | Engine:       |                                          |            |          |           |       |
    | Version:      | 19.03.6                                  |            |          |           |       |
    | API           | version:                                 | 1.4        | (minimum | version   | 1.12) |
    | Go            | version:                                 | go1.12.16  |          |           |       |
    | Git           | commit:                                  | 369ce74a3c |          |           |       |
    | Built:        | Thu                                      | Feb        | 13       | 01:26:21  |  2020 |
    | OS/Arch:      | linux/amd64                              |            |          |           |       |
    | Experimental: | false                                    |            |          |           |       |
    | containerd:   |                                          |            |          |           |       |
    | Version:      | 1.2.10                                   |            |          |           |       |
    | GitCommit:    | b34a5c8af56e510852c35414db4c1f4fa6172339 |            |          |           |       |
    | runc:         |                                          |            |          |           |       |
    | Version:      | 1.0.0-rc8+dev                            |            |          |           |       |
    | GitCommit:    | 3e425f80a8c931f88e6d94a8c831b9d5aa481657 |            |          |           |       |
    | docker-init:  |                                          |            |          |           |       |
    | Version:      | 0.18.0                                   |            |          |           |       |
    | GitCommit:    | fec3683                                  |            |          |           |       |
    #+begin_src zsh
     docker-compose version
    #+end_src
    #+RESULTS:
    | docker-compose | version  | 1.25.4, | build | unknown |     |      |
    | docker-py      | version: |   4.2.0 |       |         |     |      |
    | CPython        | version: |   3.6.9 |       |         |     |      |
    | OpenSSL        | version: | OpenSSL | 1.1.1 |      11 | Sep | 2018 |
*** Why Compose?
    - 2 parts: =CLI= and =YAML= files
    - Designed around developer workflows
    - =docker-compose= CLI a substitute for =docker= CLI
    - It hides complexity, enhancing the developer experience
      Let say you have to spin up this container time you start o re-start your development environment
      #+begin_docker run example
    docker run -p 8080:3000 -p 9229:9229 -e NODE_ENV=development -v $(pwd):app yournodeapp ../node_modules/.bin/nodemon --inspect=0.0.0.0:9229 --inspect=0.0.0.0:9229 ./bin/www
      #+end_docker
      There is a lot of complexity there, as we need to open some ports, as well as declaring volumes and additional configurations, you really do not want to type that everyday! In order to work with this complexity developers created shell scripts.
       =docker-compose= span-out of the idea, *lets not create any more scripts*, lets create tooling that automates this workflow in a more declarative way.
    - Its not designed for production environments.
      Say you need redundancy across servers, that is where orchestration shine
*** Compose File format
    - Docker standard, not yet industry
    - Defines multiple containers, networks, volumes, etc.
    - Can layer multiple layers sets of YAML files, use templates, variables, and more.
    - =docker-compose.yml= default
**** YAML
     - *YAML*: =YAML Ain't Markup Language=
     - Used by Docker, Kubernetes, Amazon, and others.
     - Its a way to describe data in a simple way so it can be used by others downstream where it is processed, really its a mean to and end. A nice thing is that is human readable, that afterwards gets transformed.
     - =:= used for key/value pair
     - Only spaces, no tabs
     - =-= used for list
     #+begin_YAML template
     version: '2.0'

     services:
       web:
         image: simple-01
         build: .
         ports:
           - "3000:3000"
     #+end_YAML
    | item    | description                                                                       |
    |---------+-----------------------------------------------------------------------------------|
    | version | '2.0' && '3.0' are different and they are not related, unfortunate naming mistake |
    | service | 1 or more containers based on a single image                                      |
    | image   | image to build from                                                               |
    | build   | =.= stands for current directory                                                  |
**** Compose YAML v2 vs v3
    - =v2= does not replace =v3=
    - =v2= focus: single-node dev/test
    - =v3= focus: multi-node orchestration
    - If not using Swarm/Kubernetes, stick to v2
*** =docker-compose= CLI
    - many =docker= commands === =docker-compose=
    - "batteries included, but swappable", meaning that it comes with defaults but they can change.
    - CLI and YAML version differ, so you need to ensure that the YAML version is supported by the CLI, of course the error can appear, just be were about it.
    - it build/pull image(s) if missing
**** =docker-compose up=
       - "one stop shop"
       - create volumes/networks/container(s)
       - starts container(s) in foreground (-d to detach)
       - =--build= to always build
**** =docker-compose down=
     - stop and delete network/container(s)
     - by default does not stop volumes
**** =docker-compose=
     *build* just build/rebuild image(s)
     *stop* just stop containers don't delete
     *ps* list "services"
     *push* to docker registry
     *logs* same as =docker= CLI
     *exec* same as =docker= CLI
*** Assignment [1/1] [100%]
    - [X] Get acquainted with the =docker-compose= https://docs.docker.com/compose/reference/overview/
** Session 2 => Node Dockerfile best practices
*** RESOURCES [3/3]
    - [X] Official Docker [[https://docs.docker.com/develop/develop-images/dockerfile_best-practices/][best practices with Dockerfile]]
    - [X] Docker file [[https://docs.docker.com/engine/reference/builder/#user][#USER]] reference
    - [X] Official node [[https://hub.docker.com/_/node][IMAGE]]
*** Docker-Node Best practices
    - =Copy= not =Add= as add can un-tar or install packages, =Add= is an old way of doing this
*** From BASE Guidelines
    - Not use *latest*, stick to even numbers of releases
    - Start with =Debian= if you are migrating an application
    - Try using =Alpine= from the start, but normally all start with *Debian*
    - Don't use =:slim=
      | =
      |-------------------------------------+------------------------------|
      | Uses the latest version of =Debian= | Uses past versions of the OS |
    - Don't use =:onbuild=
*** When to use =Alpine=, =Debian=, or =CentOS=
    | =Alpine=                                                      | =Debian=                           | =CentOS=                              |
    |---------------------------------------------------------------+------------------------------------+---------------------------------------|
    | "Small" and Security focused                                  | Debian/Ubuntu are small too ~100MB | Enterprises may require other distros |
    | Very little out of the box                                    |                                    |                                       |
    | It has it own issues, example nodemon had an issue restarting |                                    |                                       |
    | CVE scanning fails in =Alpine=                                |                                    |                                       |

#  LocalWords:  distros PID init SIGKILL ctrl tini Dockerfiles runtine BuildKit
*** Assignment making a =CentOS= Node image [3/3] [100%]              :USERS:
    Check the [[./centos-node/Dockerfile][Dockerfile]]
    - [X] Install Node in the official CentOS
    - [X] Copy Dockerfile lines from node:10
      - [X] Click on the link of the docker file of that repo, and check what is important there
    - [X] Use ENV to specify the node version
*** Running non-root Containers Users                                 :USERS:
    Best practice run the docker container as a non-root user for security reasons, however, it not enabled by default
    - Official images have =node= users
    - It's not enabled by default
    - Do this /after/  =apk/apk=  and =npm i -g=
    - Do this /before/ =npm i=
    - *This May cause permissions issues*
    - *May require* =chown node:node=
**** Change user from root to node
     - =USER node=, this comes upstream
**** Set permissions on app directory
     - =RUN mkdir app && chown -R node:node .=
**** Run  a command as a Root in Container
     - =docker-compose exec -u root=
*** Working with the Node user limits                                 :USERS:
    Working file [[/home/esteban/Apps/docker-mastery-for-nodejs/user-node/Dockerfile][here]]
**** Putting at the end of the file the change of user
      #+begin_example Dockerfile
      FROM node:10-slim

      EXPOSE 3000

      WORKDIR /node

      COPY package*.json ./

      RUN npm install && npm cache clean --force

      WORKDIR /node/app

      COPY . .
      USER node
      CMD ["node", "app.js"]
      #+end_example
       When running within the container you can see that everything is root
       #+begin_example
      /docker:hopeful_lumiere:/ #$ ls
      app  node_modules  package-lock.json  package.json
      /docker:hopeful_lumiere:/ #$ ls -al
      total 44
      drwxr-xr-x  1 root root  4096 Mar  7 19:10 .
      drwxr-xr-x  1 root root  4096 Mar  7 19:11 ..
      drwxr-xr-x  1 root root  4096 Mar  7 19:10 app
      drwxr-xr-x 41 root root  4096 Mar  7 19:10 node_modules
      -rw-rw-r--  1 root root 21260 Feb 15 20:29 package-lock.json
      -rw-rw-r--  1 root root   316 Feb 15 20:29 package.json
       #+end_example
       So this means that my app will run and will have full =read= permissions, however if it expect to write, this will not be available, like a =npm install=
**** Putting it all the way in the top
      #+begin_example Dockerfile
      FROM node:10-slim

      USER node
      EXPOSE 3000

      WORKDIR /node

      COPY package*.json ./

      RUN npm install && npm cache clean --force

      WORKDIR /node/app

      COPY . .
      CMD ["node", "app.js"]
      #+end_example

      #+begin_example
      Step 6/9 : RUN npm install && npm cache clean --force
      ---> Running in 1b499db86e41
      npm WARN checkPermissions Missing write access to /node
      npm WARN user-node@1.0.0 No description
      npm WARN user-node@1.0.0 No repository field.

      npm ERR! code EACCES
      npm ERR! syscall access
      npm ERR! path /node
      npm ERR! errno -13
      npm ERR! Error: EACCES: permission denied, access '/node'
      npm ERR!  { [Error: EACCES: permission denied, access '/node']
      npm ERR!   stack: 'Error: EACCES: permission denied, access \'/node\'',
      npm ERR!   errno: -13,
      npm ERR!   code: 'EACCES',
      npm ERR!   syscall: 'access',
      npm ERR!   path: '/node' }
      npm ERR!
      npm ERR! The operation was rejected by your operating system.
      npm ERR! It is likely you do not have the permissions to access this file as the current user
      npm ERR!
      npm ERR! If you believe this might be a permissions issue, please double-check the
      npm ERR! permissions of the file and its containing directories, or try running
      npm ERR! the command again as root/Administrator.

      npm ERR! A complete log of this run can be found in:
      npm ERR!     /home/node/.npm/_logs/2020-03-07T19_20_45_989Z-debug.log
      The command '/bin/sh -c npm install && npm cache clean --force' returned a non-zero code: 243
      #+end_example

      So we won't be able to build the image in this case
**** SO here is the fix
    With the latest version of the file [[/home/esteban/Apps/docker-mastery-for-nodejs/user-node/Dockerfile][here]]

     #+begin_example
      cd node
      /docker:hungry_meninsky:/ #$ ls
      app  node_modules  package-lock.json  package.json
      /docker:hungry_meninsky:/ #$ ls -al
      total 44
      drwxr-xr-x  1 node node  4096 Mar  7 19:24 .
      drwxr-xr-x  1 root root  4096 Mar  7 19:25 ..
      drwxr-xr-x  1 node node  4096 Mar  7 19:24 app
      drwxr-xr-x 41 node node  4096 Mar  7 19:24 node_modules
      -rw-rw-r--  1 node node 21260 Feb 15 20:29 package-lock.json
      -rw-rw-r--  1 node node   316 Feb 15 20:29 package.json
     #+end_example
     You can see that now the =app= folder has the =node= user
     Finally ensure that you also when copying files give them =node= permission as well using =COPY --chown node:node . .=, rather than =COPY . .=
*** Making Images Efficiently
    Line order matters, so it is a good practice to:
    1. Copy *only* the package and the lock files
    2. Run npm install
    3. Copy everything else
    4. Any other dependencies like =curl= install it before =COPY= and run it before npm installs
    That way you cache intelligently the node packages, something like so:
    #+begin_example
    FROM node:10-slim

    EXPOSE 3000
    RUN apt-get update && apt-get install curl
    WORKDIR /node

    COPY package.json package-lock.json* ./
    # Notice the *, this indicates copy if there
    RUN mkdir app && chown -R node:node .
    USER node

    RUN npm install && npm cache clean --force
    RUN

    WORKDIR /node/app

    COPY --chown=node:node . .
    CMD ["node", "app.js"]
    #+end_example
** Session 3 => Controlling Node processes in Containers
*** Node process Management
**** What happened before containers?
     We used to run in servers something like:
     - [[https://pm2.keymetrics.io/][PM2]]
     - [[https://nodemon.io/][nodemon]]
     - [[https://riptutorial.com/node-js/example/13417/running-and-stopping-a-forever-daemon][forever]]
     Their main purpose was to run/manage =node= processes.
     We do not need this anymore, at least in production, because Docker manages app start, stop, restart, hatchecks native and better
     Node multi-thread: Docker "Replicas"
     =There is one problem however=
     Out of the box npm/node don't handle properly shutdown signals
*** The truth about the PID-1 problem
    - PID 1 (process identifier) is the first process in the system (AKA init)
    - Init process has 2 jobs in a container:
      - reap Zombie processes
        - Happens when the parent process crashes and they are left there in the wild
      - Pass signals to sub-processes
    - Zombie processes is not a thing in Node really
    - Handling shutdown !
**** Properly CMD for healthy shutdown
     - Docker uses the following Linux signals
      | SIGINIT                                    | SIGTERM                                    | SIGKILL                                          |
      |--------------------------------------------+--------------------------------------------+--------------------------------------------------|
      | When you use a C-c                         | `docker container stop`                    | This is not a healthy way to terminate a process |
      | Its seen by the app allows gracefully stop | Its seen by the app allows gracefully stop | Here is not the case                             |
      | NPM does not handle this well              | NPM does not handle this well              | ---                                              |
      | Node can handle these but not by default   | Same here using Tiny                       | ---                                              |
*** Proper Node shutdown Options
    There are 3 ways to properly shutdown an node application
    1. *Temp*: Use =--init= to fix ctrl-c for now
       - =docker run --init -d nodeapp=
    2. *Workaround*: add tini to your image
       #+begin_example
       RUN apk --no-cache tini
       ENTRYPOINT ["/sbin/tini", "--"]
       CMD ["node", "./bin/www"]
       #+end_example
    3. *Production*: your app captures =SIGINIT= for proper exit
       You can look at this example [[./sample-graceful-shutdown/sample.js][File here]]
       #+begin_example javascript
        // place this code in your node app, ideally in index.js or ./bin/www
        //
        // you need this code so node will watch for exit signals
        // node by default doesn't handle SIGINT/SIGTERM
        // docker containers use SIGINT and SIGTERM to properly exit
        //
        // signals also aren't handeled by npm:
        // https://github.com/npm/npm/issues/4603
        // https://github.com/npm/npm/pull/10868
        // https://github.com/RisingStack/kubernetes-graceful-shutdown-example/blob/master/src/index.js
        // if you want to use npm then start with `docker run --init` to help, but I still don't think it's
        // a graceful shutdown of node process, just a forced exit
        //

        // quit on ctrl-c when running docker in terminal
        process.on('SIGINT', function onSigint () {
          console.info('Got SIGINT (aka ctrl-c in docker). Graceful shutdown ', new Date().toISOString());
          shutdown();
        });

        // quit properly on docker stop
        process.on('SIGTERM', function onSigterm () {
          console.info('Got SIGTERM (docker container stop). Graceful shutdown ', new Date().toISOString());
          shutdown();
        })

        // shut down server
        function shutdown() {
          // NOTE: server.close is for express based apps
          // If using hapi, use `server.stop`
          server.close(function onServerClosed (err) {
            if (err) {
              console.error(err);
              process.exitCode = 1;
            }
            process.exit();
          })
        }
       #+end_example
*** Assignment: Writing Node Dockerfiles [4/4] [100%]
    Assignment file [[./assignment-dockerfile/Dockerfile][here]]
    1. [X] Taken an existing image of Node
    2. [X] Expose The ports
       - When running the port ensure that you have =-p 80:3000= local port to 3000 in container
    3. [X] Install tini in node
    4. [X] Copy packages/lock files first, then npm, then Copy
*** Assignment: Testing graceful shutdowns [2/4] [50%]
    1. [X] Run it with tini built in, try to ctrl-c
    2. [X] Comment the =ENTRYPOINT=
    3. [ ] Fix this with the =--init= command to add tini at run-time
       1. [ ] Notice that tini is in a different location =/dev/init=
    4. [ ] Use =docker top <container>= to check the processes run
****  Bonus: Add Signal watch code
     You will need to update the =js= file adding the following (update for happy)
**** Conclusions
     - Controlling the termination process is very important as it avoid long waiting times
     - Ensuring that there is a graceful shutdown makes our application more performant
     - tini can help us this at run time when we cannot manage the image, or ensuring that tini is there from the start
** Session 4 => Advanced docker files with multistage built and BuildKit
*** RESOURCES
    - Advanced multi-stage built [[https://medium.com/@tonistiigi/advanced-multi-stage-build-patterns-6f741b852fae][MEDIUM]]
    - Official Docker [[https://docs.docker.com/develop/develop-images/multistage-build/][documentation]]
    - Install production only dependencies [[https://stackoverflow.com/questions/9268259/how-do-you-prevent-install-of-devdependencies-npm-modules-for-node-js-package][npm --only=prod]]
    - Better development with [[https://medium.com/better-programming/docker-in-development-with-nodemon-d500366e74df][Docker]]
    - Super charged docker build [[https://www.youtube.com/watch?v=kkpQ_UZn2uo][DockerConf18]]
    - BuiltKit [[https://docs.docker.com/develop/develop-images/build_enhancements/][Documentation]]
*** Multi-stage Docker built
    - New feature in 17.06 (mid-2017)
    - Build multiple images from one file
    - These images can =FROM= each other
    - =COPY= file between them
    - Space + Security benefits
      - As you have an image for a specific purpose and have less attack surface
    - =ARTIFACT= only
    - Great from =DEV=, =TEST= and =PROD=
*** New option in =docker built= and =Dockerfiles=
    - You can have several =FROM= and use alias =AS= so you can, in the same file use the alias to build another image
    - From that Dockerfile you can build using the =--target= like so
      #+begin_example
      docker built -t myapp:prod --target prod .
      #+end_example
*** More Multi-stage
    It allows you to test stage that runs npm tests
    - Have a CI build --target test stage before building to prod
    - Add npm install =--only=development=  to dev stage
    - Don't =COPY= code into dev stage
*** Assignment: Building a 3 stage =Dockerfile= [3/4] [75%]           :USERS:
    Sample file [[./sample-multi-stage/Dockerfile][here]], migrate current [[./sample-multi-stage/app.js][App]], with the following [[./sample-multi-stage/package.json][package.json]], and =ENTRYPOINT= [[./sample-multi-stage/bin/www][/bin/www]]
    Best example in this [[./assignment-dockerfile/Dockerfile][Dockerfile]]
    - [X] Create 3 stages for
      - [X] =prod=
        - [X] install just production dependencies, not dev dependencies
        - How to run the install tag for prod
        #+begin_example zsh
        docker build -t myapp:prod --target prod .
        #+end_example
      - [X] =dev=
        - [X] Install =dev= dependencies, another =npm= install just for that
        - [X] This has a different =CDM= *nodemon*
        #+be
        DOCKER_BUILDKIT=1 docker build -t myapp:dev --target dev .
        #+end_example
      - [X] =test=
        - [X] has dev dependencies, =run npm test=
        - notice that you can run =npm= here as you are not concerned about *PD1* processes
        #+begin_example zsh
        docker build -t myapp:test --target test .
        #+end_example
    - [X] Built all three stages
    - [X] Goal don't repeat lines
#  LocalWords:  BuiltKit config Heroku MTA dockerignore Readme md Ngnx dirs
**** Conclusions 
     - multistage without BuiltKit will trigger unnecessary layers
     - in Development not running =npm run dev= because we are shooting it to nodemon, better handle signals
     - 
*** Built Kit                                                         :USERS:
**** Resources
     - Introducing [[https://blog.mobyproject.org/introducing-buildkit-17e056cc5317][BuiltKit]]
     - Super charged Docker Built with BuiltKit [[https://www.youtube.com/watch?v=kkpQ_UZn2uo][YouTube]]
     - Official [[https://docs.docker.com/develop/develop-images/build_enhancements/][documentation]]
       - How to install BuiltKit:
         1. Easiest way
            #+begin_example zsh
            DOCKER_BUILDKIT=1 docker build .
            #+end_example
         2. By default change =/etc/docker/daemon.json=
            #+begin_example zsh
          { "features": { "buildkit": true } }
            #+end_example
            How yo buildkit
        #+begin_example zsh
        DOCKER_BUILDKIT=1 docker build -t myapp:dev --target dev .
        #+end_example
** Session 5 => Node Apps in Cloud Native Docker
*** RESOURCES 
    -[[https://12factor.net/][ 12 Factor Apps]] 
    - [[https://blog.heroku.com/the_new_heroku_4_erosion_resistance_explicit_contracts][Software Erosion]]
    - How to do [[https://docs.docker.com/storage/][bind-mount]] 
*** Cloud Native Apps
    12 Factor Apps => Focused for distributed systems 
    Important to review carefully the =.dockerignore= file
**** Follow the 12 factors, especially
     - Use environment variables for config in:
       1. Dockerfiles
       2. Compose files, and also
       3. In your app
     - Log to =stdout/stderr=
     - Pin all versions even =npm=
     - Gracefully exit =SIGTERM/INIT=
     - Create a =.dockerignore= 
**** First, what is 12 Factor app
     - Heroku wrote a highly respectable guide to creating distributed apps
     - Even-though its been in the industry over a year, you should aim to use it always
     - To create an application that does not turns old fast
     - Shared in a way that makes sense to a lot of people
     - Containers are almost going to be distributed apps
     - Good news you are using most of the 12 out of the box with Docker
**** Factor: =config=
     - Avoid Software [[https://blog.heroku.com/the_new_heroku_4_erosion_resistance_explicit_contracts][Erosion]]
       - How does it work Erosion-resistance is an outcome of strong separation between the app and the infrastructure on which it runs.
*** Assignment: MTA (Migrating Traditional Apps)
    We will migrate this [[./assignment-mta/index.js][App.js]] with these files to container found in the  =./assigment-mta= 
    1. [[./assignment-mta/Dockerfile][Dockerfile]]
    2. [[./assignment-mta/.dockerignore][.dockerignore]] 
    #+begin_example zsh
    DOCKER_BUILDKIT=1 docker build -t node8 .
    #+end_example
    How to mount the application 
    #+begin_example zsh
    --mount type=bind,source="$(pwd)"/target,target=/app,readonly
    docker run --mount type=bind,source="$(pwd)"/in,target=/node/app/in --mount type=bind,source="$(pwd)"/out,target=/node/app/out --env CHACOAL_FACTOR=10 node8
    docker run -v "$(pwd)"/in:/node/app/in -v "$(pwd)"/out:/node/app/out node8
    docker run -v $(pwd)/in:/node/app/in -v $(pwd)/out:/node/app/out node8
    #+end_example
    Maybe use this [[./sample-multi-stage/Dockerfile][Dockerfile]] 
**** Checklist [100%] [3/3]:
     - [X] Add a *.dockerignore*
     - [X] Create a =Dockerfile=
     - [X] Change =Winston= transport to console, opposed to logging to a file
**** MTA Requirements [100%] [5/5]:
     - [X] See *Readme.md* for =app= details
     - [X] Image should not include =in=, =out=, =node_modules=, or =logs= directories in =.dockerignore=
     - [X] Open the =index.js= file to update transport of Winston to console
       -*Hint:* =winston.transport.Console= 
       -*Other Option:* create a symlink in in the dockerfile where the logs are going to go, that is how the official Ngnx does it, so Symlink to =stdout= and =stderr= 
     - [X] *Bind-mount* =in= and =out= dirs, back out to the host
     - [X] Change the *environment* variable to get different results
       - Set =CHARCOAL_FACTOR= to *0.1*
**** 
**** MTA Outcomes [0%] [0/4]:
     - [ ] Running container with =./in= and =./out= *bind-mounts* results in new chalk images in =out= host
     - [ ] Changing =--env CHARCOAL_FACTOR= to *10*, the image looks different
     - [ ] No *gifs* in the image
     - [ ] When doing a =docker logs= shows Winston output
#  LocalWords:  gifs
**** Conclusions
     1. You are able to migrate a traditional app =MTA=
     2. Setup correctly =Environment Variables=
     3. Check that dependencies are correct
     4. That the app is flexible enough
** Session 6 => Docker compose for local development
   Best local Setup for development using =docker-compose= features, there are a lot of =tips and tricks= and a Big assignment at the end
*** RESOURCES
    - Compose [[./https://docs.docker.com/compose/compose-file/compose-file-v2/][version 2]] , if you are not using orchestration
    - Good [[./compose-tips/good.yml][docker-compose]]
    - Bad [[./compose-tips/bad.yml][docker-compose]]
    - Performance tuning for [[https://docs.docker.com/docker-for-mac/osxfs-caching/][volume mounts]]
    - File Sharing exclusive for [[https://docs.docker.com/docker-for-mac/osxfs-caching/][MAC-OS]]
    - User guided caching in [[https://www.docker.com/blog/user-guided-caching-in-docker-for-mac/][Docker-MACos]] 
*** Compose Project tips
**** Dos
     - Use =docker-compose= for local dev
     - Use =v2= format for local dev:
       - v2 only: *depends_on*, control => hardware specific
     - Use study compose file and CLI features
**** Don't
     - Unnecessary: =alias= & =container_name=
     - Legacy: =expose= & =links=
     - No need to set =defaults=
     - Use host file paths
     - Don't =bind-mount= databases
     - For development only, don't rebuild images, just restart node. Like mounting your host file over the app image.
       Technically an image with no source code, and we bind mounting it in.
*** =node_modules= in *Images* 
    - *Problem*: We should not built images from node files from the host, as we could develop in Mac or Windows
      Example: =node-gyp= that builds especially for an Architecture 
      Solution: Put the =node_modules= in the =.dockerignore= file
*** =node_modules= in *Bind mounts* 
    - *Problem*: We cannot bin-mount node_modules as the have different architecture
      Lets look at this [[./sample-express/app.js][App.js]], with this [[./sample-express/Dockerfile][Dockerfile]] 
****  Two potential solutions:
       1. Never use =npm install= on host, run =npm install= in compose, however is not that flexible
         using this docker-compose
         Using this [[./sample-express/Dockerfile-solution-1][Dockerfile solution 1]] as template
         With =docker-compose= we can run a
         #+begin_example zsh
         docker-compose run express npm install
         #+end_example
         and the we can run a 
         #+begin_example zsh
         docker-compose up
         #+end_example
         to run the application.
         Conclusion:
          1. You can't run a =docker-compose up= until you run =docker-compose run= on the services
       2. Move modules in image, hide modules from host, more setup but more flexible
          Using this [[./sample-express/Dockerfile-solution-2][Dockerfile solution 2]]  and [[./sample-express/docker-compose-solution-2.yml][docker-compose-solution-2]] 
          - Move the =node_modules= up a directory in =Dockerfile=
          - Use empty volume to hide =node_modules= on =bind mount=
          In this case run a =npm install= so there is a =node_modules= in the host
*** NPM, YARN, and others tools in Compose
    pretty much when to run  =docker-compose run= or =docker-compose exec service= as well you can just run a bash in the container
*** File monitoring and Node Auto Restart 
    Take another express app using [[./sample-nodemon/Dockerfile][nodemon]] 
*** Startup order and Dependencies
    =Problem= Multi-services app start out from order, node might exit or cycle  
    Multi-container apps needs:
    - Dependency awareness
    - Name resolution (DNS)
    - Connection failure handling
**** Dependecy awareness =dependens_on= => use V2
     - =dependens_on= is really more about dependency relationships, by default it does not wait that is correctly up
     - Fixes name resolution issues with "can't resolve <service_name>"
     - Finally it means that if your service "x" =dependes_on= "y", let "y" start first, does not mean however, that is ready before "x" by default
     - compose YAML v2: works with healthchecks like "await for script"
**** Connection Failure Handling
     - =restart:on failure=
       - *Good:* helps slow db startup and Node.js failing. Better: =dependens_on=
       - *Bad:* could spike CPU with restart cycling
       - *Long Term:* build connection timeouts, buffer and retry in your apps
*** Health Checks for =depends_on=
    1. We can find the /incomplete/ version of the =docker-compose= [[./depends-on/docker-compose.yml][file]]
    2. We can find the /complete/ version using =health-checks= in this [[./depends-on/healthy-compose.yml][file]]
     #+begin_example yaml
      depends_on:
        api:
          # this requires a compose file version => 2.3 and < 3.0
          condition: service_healthy
     #+end_example
     notice that we added the =condition: service_healthy= statement, then on the thing you are depending on you have to put the health check
     #+begin_example yaml
      healthcheck:
        test: curl -f http://127.0.0.1
     #+end_example
**** RESOURCES 
     - [[https://docs.docker.com/compose/compose-file/compose-file-v2/#healthcheck][Docker Official documentation]]
     - [[https://github.com/docker-library/healthcheck][Github, enable official HEALTHCHECKS]] 
*** Making Micro-services Easier
**** *Problem:* many HTTP endpoints, many ports
    *Solution:* =Nginx/HAProxy/Traefix= using their /reverse_proxy/ solution
    Resources:
      - Medium use [[https://medium.com/@sumankpaul/use-nginx-proxy-and-dnsmasq-for-user-friendly-urls-during-local-development-a2ffebd8b05d][nginx proxies in local development]]
      - [[https://containo.us/traefik/][traefik]] cloud router
      - [[https://github.com/nginx-proxy/nginx-proxy][nginx-proxy]]  for Docker Containers using docker-gen
**** *Problem:* =CORS= issues in local development
    *Solution:* Proxy with =*= header
    Resources:
      - Repo [[https://github.com/docker-solr/docker-solr/issues/182][Question 1]]
      - Repo [[https://github.com/nginx-proxy/nginx-proxy/issues/804][Question 2]] 
**** *Problem:* HTTPS for local development
    *Solution:* Certificates for [[https://letsencrypt.org/docs/certificates-for-localhost/][localhost]] 
**** *Problem:* Local DNS for many End points
    *Solution:* use =x.localhost=, =y.localhost= in Chrome, however, is Chrome specific
    Resources:
      - Use wildcard domains like [[http://xip.io/][xio.io]]
      - Use [[https://www.stevenrombauts.be/2018/01/use-dnsmasq-instead-of-etc-hosts/][DNSMASQ]] instead of /ETC/HOST this is a local DNS server running on your local machine
      - Manually edit host files:
        | Cons                                                                            | Pros |
        |---------------------------------------------------------------------------------+------|
        | Does not work with wild cards, ergo you need to add manually each micro-service |      |
        |                                                                                 |      |
**** *Demo:* Setting up proxy (./sample-local-proxy)
     Notice that =docker-compose= (this is a general =docker= issue), will only work if the VPN is disabled, the following [[https://stackoverflow.com/questions/45692255/how-make-openvpn-work-with-docker][link]] to make them work together.
***** [[./sample-local-proxy/nginx-proxy.yml][Nginx-proxy]] 
      - [[https://hub.docker.com/r/jwilder/nginx-proxy/][Docker-hub]]
      #+begin_src zsh
      cd ./sample-local-proxy/ && cp nginx-proxy.yml docker-compose.yml
      #+end_src
      #+RESULTS:
      run a =docker-compose up=, and you can now go [[http://dude.localhost/][dude.localhost]] and [[http://ghost.localhost/][ghost.localhost]]   
***** [[./sample-local-proxy/traefik-proxy.yml][Traefik-proxy]] 
      [[https://docs.traefik.io/getting-started/quick-start/][Quick-Start]] 
      #+begin_src zsh
      cd ./sample-local-proxy/ && cp traefik-proxy.yml docker-compose.yml
      #+end_src

      #+RESULTS:
*** VS Code, Debugging, and TypeScript
    - Obviously VS Code is a well rounded as well as they have =docker= and =compose= features built in, however, better if I not tie to that
    - Debugging work when we enable nodemon and remote via TCP, feature of Docker!!
    - TypeScript compile and other pre-processors go in =nodemon.json=
**** RESOURCES 
     - [[https://code.visualstudio.com/docs/nodejs/nodejs-debugging][Debug]] an app using VSCode
     - [[https://github.com/Microsoft/vscode-recipes/tree/master/Docker-TypeScript][Debugging TypeScript in an Docker Container]]
     - [[https://github.com/TypeStrong/ts-node][ts-node]]  
**** *Demo:* (./typescript)
      - [[./typescript/Dockerfile][Dockerfile]]
        - Multistage built
      - [[./typescript/docker-compose.yml][docker-compose.yml]]
        - =target: dev= gives us a target from the image
        - =volumes= the =- .:/app=, is solution 1 of the *Bind Mounts* demo
      - [[./typescript/package.json][package.json]] 
      - [[./typescript/tsconfig.json][tsconfig.json]] 
      - [[./typescript/nodemon.json][nodemon.json]]
        - We tell to watch the src file and ignore the tests
        - notice the =exec= in =--inspect=0.0.0.0:9229=
        - =ts-node/register= which automatically compiles typescript
